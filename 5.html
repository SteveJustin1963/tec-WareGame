<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ASCII War Game</title>
<style>
  body { background: #000; color: #0f0; font-family: monospace; margin: 0; padding: 0; overflow: hidden; }
  #menu { width: 100%; text-align: center; background: #030; border-bottom: 1px solid #0f0; padding: 8px 0; font-size: 14px; line-height: 1.4; z-index: 10; }
  #hud { font-weight: bold; }
  #controls { margin: 6px 0; }
  button { background: #030; color: #0f0; border: 1px solid #0f0; padding: 4px 8px; margin: 0 5px; cursor: pointer; font-family: monospace; }
  #board { white-space: pre; font-size: 16px; line-height: 1; text-align: center; margin-top: 10px; }
</style>
</head>
<body>
<div id="menu">
  <div id="hud">Health: 1000 | Bag: 0 | Rocks: 0</div>
  <div id="controls">
    Arrow Keys = Move • Space = Attack • R = Respawn • w = Build Wall • e = Erase Wall • b = Break Wall & Collect Rock • $ = Bomb • c = Hold to Charge Catapult (1 tile/sec)<br>
    @=You E=Enemy F=Food ^=Mountain ~=River o=Lake █=Wall %=Forest $=Bomb #=Treasure + = Debris
  </div>
  <button onclick="respawnMap()">Respawn Map</button>
</div>
<pre id="board"></pre>

<script>
// ============================================================================
// 1. CONSTANTS & GLOBAL STATE
// ============================================================================
const CHARS = { 
  empty: ' ', player: '@', enemy: 'E', food: 'F', mountain: '^', river: '~', 
  lake: 'o', wall: '█', bomb: '$', forest: '%', treasure: '#', impact: '+'
};

let player = { x: 0, y: 0, health: 1000, moves: 0, bag: [], bagCount: 0, rocks: 0, lastDirection: [0, 0] };
const ITEMS = ['Sword','Shield','Potion','Amulet','Boots','Cloak','Ring','Scroll','Gem','Key'];

let enemies = [], foods = [], walls = [], rivers = [], bombs = [], forests = [], treasures = [];
let catapultImpacts = [], catapultAnimation = null;
let catapult = { active: false, chargeStart: null };
let heightmap = new Map();
let seed = Math.random() * 10000;

const board = document.getElementById('board');
const hud = document.getElementById('hud');

// ============================================================================
// 2. NOISE & TERRAIN
// ============================================================================
function noise2D(x, y) { return Math.abs(Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453) % 1; }
function fractalNoise(x, y, octaves = 5, scale = 0.02, persistence = 0.55) {
  let total = 0, amplitude = 1, freq = scale, max = 0;
  for (let i = 0; i < octaves; i++) {
    total += noise2D(x * freq, y * freq) * amplitude;
    max += amplitude; amplitude *= persistence; freq *= 2;
  }
  return total / max;
}
function getHeight(x, y) {
  const key = x + ',' + y;
  if (heightmap.has(key)) return heightmap.get(key);
  const h = fractalNoise(x, y, 6, 0.02, 0.55);
  heightmap.set(key, h);
  return h;
}
function isMountain(x, y) { 
  const h = getHeight(x, y); 
  return h < 0.3 && noise2D(Math.floor(x / 4), Math.floor(y / 4)) < 0.55; 
}
function isWall(x, y) { 
  for (const pattern of walls) for (const w of pattern) if (w.x === x && w.y === y) return true;
  return false; 
}
function isRiver(x, y) {
  for (const path of rivers) for (const seg of path) 
    if (!seg.lake && Math.abs(seg.x - x) <= 1 && Math.abs(seg.y - y) <= 1) return true;
  return false;
}
function isLake(x, y) {
  for (const path of rivers) for (const seg of path) 
    if (seg.lake && Math.abs(seg.x - x) <= 1 && Math.abs(seg.y - y) <= 1) return true;
  return false;
}
function isForest(x, y) { return forests.some(f => f.x === x && f.y === y); }
function isTreasure(x, y) { return treasures.some(t => t.x === x && t.y === y); }

// ============================================================================
// 3. WORLD GENERATION
// ============================================================================
function addWallBlock(x, y) { walls.push([{ x, y }]); }
function removeWallBlock(x, y) {
  for (let i = 0; i < walls.length; i++) {
    walls[i] = walls[i].filter(w => !(w.x === x && w.y === y));
  }
  walls = walls.filter(p => p.length > 0);
}
function findFreeSpotAround(x, y) {
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx, dy] of dirs) {
    const tx = x + dx, ty = y + dy;
    const t = tile(tx, ty, true);
    if (t === ' ' || t === '~' || t === 'o') return { x: tx, y: ty };
  }
  return { x, y };
}

function generateWalls() {
  walls = [];
  for (let i = 0; i < 8; i++) {
    let x = Math.floor(Math.random() * 400 - 200);
    let y = Math.floor(Math.random() * 400 - 200);
    const pattern = [];
    const w = 4 + Math.floor(Math.random() * 4);
    const h = 4 + Math.floor(Math.random() * 4);
    for (let dx = 0; dx < w; dx++) {
      for (let dy = 0; dy < h; dy++) {
        if (Math.random() > 0.3) pattern.push({ x: x + dx, y: y + dy });
      }
    }
    walls.push(pattern);
  }
}

function generateRivers() {
  rivers = [];
  const sources = [];
  for (let i = 0; i < 8; i++) {
    let x = Math.floor(Math.random() * 400 - 200);
    let y = Math.floor(Math.random() * 400 - 200);
    if (getHeight(x, y) < 0.45) continue;
    sources.push({ x, y });
  }
  for (const src of sources) {
    let x = src.x, y = src.y;
    const path = [];
    for (let j = 0; j < 30; j++) {
      path.push({ x, y });
      const gradX = getHeight(x + 1, y) - getHeight(x - 1, y);
      const gradY = getHeight(x, y + 1) - getHeight(x, y - 1);
      if (Math.abs(gradX) + Math.abs(gradY) < 0.02) break;
      x += gradX > 0 ? 1 : -1;
      y += gradY > 0 ? 1 : -1;
      if (Math.random() < 0.2) { x += Math.sign(Math.random() - 0.5); y += Math.sign(Math.random() - 0.5); }
    }
    for (let dx = -2; dx <= 2; dx++) for (let dy = -2; dy <= 2; dy++) path.push({ x: x + dx, y: y + dy, lake: true });
    rivers.push(path);
  }
}

function generateForests() {
  forests = [];
  for (let i = 0; i < 120; i++) {
    let x = Math.floor(Math.random() * 400 - 200);
    let y = Math.floor(Math.random() * 400 - 200);
    const h = getHeight(x, y);
    if (h > 0.35 && h < 0.65 && !isMountain(x, y) && !isRiver(x, y) && !isLake(x, y) && !isWall(x, y)) {
      forests.push({ x, y });
      for (let j = 0; j < 10; j++) {
        const dx = Math.floor(Math.random() * 7 - 3);
        const dy = Math.floor(Math.random() * 7 - 3);
        if (!isMountain(x + dx, y + dy)) forests.push({ x: x + dx, y: y + dy });
      }
    }
  }
}

function generateFoods() {
  foods = [];
  const gridSize = 10;
  const cellWidth = 40;
  const cellHeight = 40;
  let attempts = 0;
  while (foods.length < 100 && attempts < 1000) {
    const cellX = Math.floor(Math.random() * gridSize);
    const cellY = Math.floor(Math.random() * gridSize);
    const x = -200 + cellX * cellWidth + Math.floor(Math.random() * cellWidth);
    const y = -200 + cellY * cellHeight + Math.floor(Math.random() * cellHeight);
    if (!isMountain(x, y) && !isWall(x, y) && !isLake(x, y) && !isRiver(x, y) && !isForest(x, y) && !isTreasure(x, y)) {
      foods.push({ x, y });
    }
    attempts++;
  }
}

function generateTreasures() {
  treasures = [];
  const nearPlayer = { x: player.x + 5, y: player.y + 5, item: ITEMS[Math.floor(Math.random() * ITEMS.length)] };
  if (!isMountain(nearPlayer.x, nearPlayer.y) && !isWall(nearPlayer.x, nearPlayer.y) && !isLake(nearPlayer.x, nearPlayer.y) && !isRiver(nearPlayer.x, nearPlayer.y) && !isForest(nearPlayer.x, nearPlayer.y)) {
    treasures.push(nearPlayer);
  }
  for (let i = 0; i < 50; i++) {
    let x = Math.floor(Math.random() * 400 - 200);
    let y = Math.floor(Math.random() * 400 - 200);
    if (!isMountain(x, y) && !isWall(x, y) && !isLake(x, y) && !isRiver(x, y) && !isForest(x, y) && !isTreasure(x, y))
      treasures.push({ x, y, item: ITEMS[Math.floor(Math.random() * ITEMS.length)] });
  }
}

function addFoodEvery100Steps() {
  if (player.moves % 100 === 0) {
    const range = 300;
    const x = player.x + Math.floor(Math.random() * range - range / 2);
    const y = player.y + Math.floor(Math.random() * range - range / 2);
    if (!isMountain(x, y) && !isWall(x, y) && !foods.some(f => f.x === x && f.y === y) && !isTreasure(x, y))
      foods.push({ x, y });
  }
}

// ============================================================================
// 4. RENDERING
// ============================================================================
function isImpact(x, y) {
  const now = Date.now();
  for (const i of catapultImpacts) {
    if (now - i.startTime >= 5000) continue;
    const dx = Math.abs(i.x - x), dy = Math.abs(i.y - y);
    const maxD = Math.max(dx, dy);
    if (maxD >= 2 && maxD <= 3 && dx <= 3 && dy <= 3) {
      const index = Math.floor(Math.random() * i.symbols.length);
      return i.symbols[index];
    }
  }
  return null;
}

function tile(x, y, raw = false) {
  if (catapultAnimation && catapultAnimation.x === x && catapultAnimation.y === y) return CHARS.wall;
  if (!raw) {
    const impactSymbol = isImpact(x, y);
    if (impactSymbol) return (Math.floor(Date.now() / 500) % 2 === 0) ? impactSymbol : CHARS.empty;
  }
  if (bombs.some(b => b.x === x && b.y === y)) return CHARS.bomb;
  if (enemies.some(e => e.x === x && e.y === y)) return CHARS.enemy;
  if (treasures.some(t => t.x === x && t.y === y)) return CHARS.treasure;
  if (foods.some(f => f.x === x && f.y === y)) return CHARS.food;
  if (isMountain(x, y)) return CHARS.mountain;
  if (isWall(x, y)) return CHARS.wall;
  if (isLake(x, y)) return CHARS.lake;
  if (isRiver(x, y)) return CHARS.river;
  if (isForest(x, y)) return CHARS.forest;
  return CHARS.empty;
}

function render() {
  let view = '';
  const width = Math.floor(window.innerWidth / 10);
  const height = Math.floor(window.innerHeight / 16);
  const halfW = Math.floor(width / 2);
  const halfH = Math.floor(height / 2);
  for (let y = player.y - halfH; y <= player.y + halfH; y++) {
    for (let x = player.x - halfW; x <= player.x + halfW; x++) {
      view += (x === player.x && y === player.y) ? CHARS.player : tile(x, y);
    }
    view += '\n';
  }
  hud.textContent = `Health: ${player.health} | Bag: ${player.bagCount} | Rocks: ${player.rocks}`;
  board.textContent = view;
  if (player.health <= 0) {
    setTimeout(() => { alert('You died! Respawning...'); respawnMap(); }, 500);
  }
}

// ============================================================================
// 5. ENEMIES & AI
// ============================================================================
function canSee(a, b, c, d) {
  let x0 = a, y0 = b, x1 = c, y1 = d;
  let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
  let sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  while (true) {
    if (isMountain(x0, y0) || isWall(x0, y0)) return false;
    if (x0 === x1 && y0 === y1) return true;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; x0 += sx; }
    if (e2 < dx) { err += dx; y0 += sy; }
  }
}

function generateEnemiesAround(px, py, radius = 50) {
  enemies = [];
  for (let y = py - radius; y <= py + radius; y++) {
    for (let x = px - radius; x <= px + radius; x++) {
      const n = noise2D(x, y);
      if (n >= 0.05 && n < 0.06) {
        enemies.push({ x, y, hp: 3, alerted: false, attached: false });
      }
    }
  }
}

function moveEnemy(e, dx, dy) {
  const nx = e.x + dx, ny = e.y + dy;
  const t = tile(nx, ny, true);
  if (t === ' ' || t === '~' || t === 'o' || t === '%') { e.x = nx; e.y = ny; }
}

function updateAttachments() {
  for (const e of enemies) { e.attached = (Math.abs(e.x - player.x) <= 1 && Math.abs(e.y - player.y) <= 1); }
}

function enemyAI() {
  for (const e of enemies) {
    const d = Math.abs(e.x - player.x) + Math.abs(e.y - player.y);
    if (d <= 10 && canSee(e.x, e.y, player.x, player.y) && !isForest(player.x, player.y)) e.alerted = true;
    if (e.alerted && canSee(e.x, e.y, player.x, player.y)) {
      const dx = Math.sign(player.x - e.x);
      const dy = Math.sign(player.y - e.y);
      moveEnemy(e, dx, dy);
    }
  }
  updateAttachments();
}

function attachedEnemiesCount() { updateAttachments(); return enemies.filter(e => e.attached).length; }

// ============================================================================
// 6. BOMBS
// ============================================================================
const BOMB_COST = 50;
const BOMB_DELAY_MS = 5000;
const BOMB_RANGE = 5;

function placeBomb() {
  player.health = Math.max(0, player.health - BOMB_COST);
  const bomb = { x: player.x, y: player.y, explodeAt: Date.now() + BOMB_DELAY_MS, timeoutId: null };
  bombs.push(bomb);
  bomb.timeoutId = setTimeout(() => explodeBomb(bomb), BOMB_DELAY_MS);
  render();
}

function explodeBomb(bomb) {
  bombs = bombs.filter(b => b !== bomb);
  const killed = [];
  for (const e of enemies) {
    if (Math.abs(e.x - bomb.x) <= BOMB_RANGE && Math.abs(e.y - bomb.y) <= BOMB_RANGE) killed.push(e);
  }
  for (const k of killed) enemies = enemies.filter(e => e !== k);
  render();
}

function cancelAllBombs() { for (const b of bombs) clearTimeout(b.timeoutId); bombs = []; }

// ============================================================================
// 7. CATAPULT
// ============================================================================
function launchCatapult(chargeTime) {
  if (!player.rocks) return;
  player.rocks--;
  const distance = Math.max(1, Math.floor(chargeTime / 1000));
  const [dx, dy] = player.lastDirection;
  if (dx === 0 && dy === 0) return;

  let tx = player.x + dx, ty = player.y + dy;
  let step = 1;

  function animateRock() {
    if (step >= distance || isMountain(tx + dx, ty + dy) || isWall(tx + dx, ty + dy)) {
      catapultAnimation = null;
      impact(tx, ty);
      render();
      return;
    }
    tx += dx; ty += dy; step++;
    catapultAnimation = { x: tx, y: ty };
    render();
    setTimeout(animateRock, 100);
  }

  catapultAnimation = { x: tx, y: ty };
  render();
  setTimeout(animateRock, 100);
}

function impact(cx, cy) {
  const symbols = [];
  const impacted = new Set();

  for (let dx = -1; dx <= 2; dx++) {
    for (let dy = -1; dy <= 2; dy++) {
      const x = cx + dx, y = cy + dy;
      if (x === player.x && y === player.y) continue;
      const key = `${x},${y}`;
      if (impacted.has(key)) continue;
      impacted.add(key);

      const t = tile(x, y, true);
      if (t !== CHARS.empty) symbols.push(t);

      enemies = enemies.filter(e => !(e.x === x && e.y === y));
      foods = foods.filter(f => !(f.x === x && f.y === y));
      treasures = treasures.filter(t => !(t.x === x && t.y === y));
      bombs = bombs.filter(b => !(b.x === x && b.y === y));
      removeWallBlock(x, y);
      forests = forests.filter(f => !(f.x === x && f.y === y));
      rivers.forEach(path => {
        path = path.filter(seg => !(Math.abs(seg.x - x) <= 1 && Math.abs(seg.y - y) <= 1));
      });
    }
  }

  const radius = 3;
  for (let a = 0; a < Math.PI * 2; a += 0.4) {
    const rx = Math.round(cx + Math.cos(a) * radius);
    const ry = Math.round(cy + Math.sin(a) * radius);
    const sym = symbols.length > 0 ? symbols[Math.floor(Math.random() * symbols.length)] : CHARS.impact;
    catapultImpacts.push({ x: rx, y: ry, symbols: [sym], startTime: Date.now() });
  }

  setTimeout(() => {
    catapultImpacts = catapultImpacts.filter(i => Date.now() - i.startTime < 5000);
    render();
  }, 5000);
}

// ============================================================================
// 8. PLAYER ACTIONS
// ============================================================================
function move(dx, dy) {
  player.lastDirection = [dx, dy];
  const nx = player.x + dx, ny = player.y + dy;
  const t = tile(nx, ny, true);
  if (t !== '^' && t !== '█') {
    player.x = nx; player.y = ny; player.moves++;
    addFoodEvery100Steps();
    enemyAI();
    const attached = attachedEnemiesCount();
    const baseLoss = (player.moves % 10 === 0) ? 1 : 0;
    let loss = baseLoss + (attached > 0 ? attached : 0);
    if (t === '~' || t === 'o') loss += 3;
    player.health = Math.max(0, player.health - loss);
    eatFood();
    collectTreasure();
    render();
  }
}

function eatFood() {
  const i = foods.findIndex(f => f.x === player.x && f.y === player.y);
  if (i > -1) { foods.splice(i, 1); player.health = Math.min(1000, player.health + 100); }
}

function collectTreasure() {
  const i = treasures.findIndex(t => t.x === player.x && t.y === player.y);
  if (i > -1) {
    const item = treasures[i].item;
    player.bag.push(item); player.bagCount++;
    treasures.splice(i, 1);
  }
}

function attack() {
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dx, dy] of dirs) {
    const e = enemies.find(en => en.x === player.x + dx && en.y === player.y + dy);
    if (e) {
      e.hp--;
      player.health = Math.max(0, player.health - 1);
      if (e.hp <= 0) enemies = enemies.filter(en => en !== e);
      break;
    }
  }
  render();
}

function breakWallForRock() {
  const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
  let broken = false;
  for (const [dx, dy] of dirs) {
    const tx = player.x + dx, ty = player.y + dy;
    if (isWall(tx, ty)) {
      removeWallBlock(tx, ty);
      player.rocks++;
      broken = true;
    }
  }
  if (broken) { player.health = Math.max(0, player.health - 1); render(); }
}

function eraseWallHere() {
  const dirs = [[0,0],[1,0],[-1,0],[0,1],[0,-1]];
  let erased = false;
  for (const [dx, dy] of dirs) {
    const tx = player.x + dx, ty = player.y + dy;
    if (isWall(tx, ty)) { removeWallBlock(tx, ty); erased = true; }
  }
  if (erased) { player.health = Math.max(0, player.health - 1); render(); }
}

function buildWallHere() {
  addWallBlock(player.x, player.y);
  player.health = Math.max(0, player.health - 5);
  const next = findFreeSpotAround(player.x, player.y);
  player.x = next.x; player.y = next.y;
  render();
}

function respawnMap() {
  cancelAllBombs();
  if (catapultAnimation) clearTimeout(catapultAnimation.timeoutId);
  catapultAnimation = null;
  catapultImpacts = [];
  catapult = { active: false, chargeStart: null };
  seed = Math.random() * 10000;
  heightmap.clear();
  generateWalls(); generateRivers(); generateForests(); generateFoods(); generateTreasures();
  generateEnemiesAround(0, 0);
  player = { x:0,y:0,health:1000,moves:0,bag:[],bagCount:0,rocks:0,lastDirection:[0,0] };
  render();
}

// ============================================================================
// 9. INPUT HANDLING
// ============================================================================
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.key.startsWith('Arrow')) e.preventDefault();
  if (e.code === 'Space') { attack(); return; }
  if (e.key === 'ArrowUp') { move(0, -1); return; }
  if (e.key === 'ArrowDown') { move(0, 1); return; }
  if (e.key === 'ArrowLeft') { move(-1, 0); return; }
  if (e.key === 'ArrowRight') { move(1, 0); return; }
  if (e.key === 'r' || e.key === 'R') { respawnMap(); return; }
  if (e.key === 'w') { buildWallHere(); return; }
  if (e.key === 'e') { eraseWallHere(); return; }
  if (e.key === 'b') { breakWallForRock(); return; }
  if (e.key === '$') { placeBomb(); return; }
  if (e.key === 'c' && player.rocks > 0) {
    catapult.active = true;
    catapult.chargeStart = Date.now();
  }
});

document.addEventListener('keyup', e => {
  if (e.key === 'c' && catapult.active && catapult.chargeStart) {
    const chargeTime = Date.now() - catapult.chargeStart;
    catapult.active = false;
    catapult.chargeStart = null;
    launchCatapult(chargeTime);
  }
});

window.addEventListener('resize', render);

// ============================================================================
// 10. INITIALIZATION
// ============================================================================
generateWalls(); generateRivers(); generateForests(); generateFoods(); generateTreasures();
generateEnemiesAround(0, 0);
render();
</script>
</body>
</html>